"""
Provides functions for open-ended research using LLM when the user's query requires
information not directly available in the predefined categories.

For example, if a user asks for "Australian artists" but we don't have that
category directly, we can use this module to research and suggest appropriate
artists that match the criteria.

Requires:
  - pydantic-ai library installed (`pip install pydantic-ai`)
  - GEMINI_API_KEY environment variable set with a valid Google Generative Language API key.
    (Get one from https://aistudio.google.com/apikey)
"""

import asyncio
import os
from typing import Optional
from pydantic_ai import Agent
from pydantic import BaseModel, Field
import dotenv
from models import get_all_categories, BijukaruUrlParams
from wikiart import WikiArtCategory, search_wikiart_for_artists, get_wikiart_feed
from ukiyoe import get_ukiyo_e_feed
from reddit import get_reddit_feed
from apod import search_apod

# Import Feed, FeedItem, Category from schema
from schema import Feed, FeedItem, Category

dotenv.load_dotenv()

# --- Pydantic Models for Multi-Agent Flow ---


class NarrativeItem(BaseModel):
    """Represents one item (artwork) in the narrative plan.
    Focuses on *what* artwork and *why*, not the final details.
    """

    title: str = Field(description="The title of the artwork chosen for the narrative.")
    artist: Optional[str] = Field(
        None, description="The artist of the artwork (if known or relevant)."
    )
    narrative_description: str = Field(
        description="Why this artwork is included in the story/narrative."
    )


class NarrativePlan(BaseModel):
    """The output of the Story Curator agent.
    Outlines the narrative structure and the conceptual items.
    """

    suggested_category_name: str = Field(
        description="A user-friendly name for the curated feed category."
    )
    items: list[NarrativeItem] = Field(
        description="The list of artworks selected to tell the story."
    )
    curator_llm_thinking: str = Field(
        description="The curator agent's reasoning for the narrative plan."
    )
    curator_userfriendly_message: str = Field(
        description="A user-friendly message introducing the curated story."
    )


class ResearchRequest(BaseModel):
    """Input for the Detail Researcher agent.
    Specifies the artwork for which details are needed.
    """

    title: str
    artist: Optional[str] = None
    # Optional: Add context from narrative_description if helpful for search?


# --- Original Models (Keep as needed) ---

class LLMResearchResult(BaseModel):
    """
    Represents the result of an open-ended research query to help determine appropriate
    gallery parameters for user requests that don't directly match existing categories.
    """

    research_query: str = Field(
        ...,
        description="The research query from the user.",
        examples=["Show me Ukiyo-e artists from the 20th century"],
    )
    research_result: str = Field(
        ...,
        description="A concise research result from the LLM.",
        examples=[
            """Here is a concise list of some prominent artists associated with the Shin-hanga movement in the 20th century:

Kawase Hasui (1883-1957)
Yoshida Hiroshi (1876-1950)
Ito Shinsui (1898-1972)
Hashiguchi Goyō (1880-1921)
Ohara Koson (Shōson) (1877-1945)
Tsuchiya Koitsu (1870-1949)
Natori Shunsen (1886-1960)"""
        ],
    )


# Define a new model for the curated feed output
class CuratedFeed(Feed):
    """
    Represents a curated feed of images generated by an LLM based on a narrative query.
    Includes the LLM's reasoning and a user-friendly message.
    """

    llm_thinking: str = Field(
        description="Explain your reasoning for selecting the items in the feed and the overall narrative structure. This will be shown to the user.",
    )
    userfriendly_message: str = Field(
        description="A user-friendly message to the user explaining the curated feed.",
    )


class SuggestedBijukaruUrlParams(BijukaruUrlParams):
    """
    Represents a suggested gallery parameters from the LLM.
    """

    llm_thinking: str = Field(
        description="Explain your reasoning for the category and image_id you chose. This will be shown to the user.",
    )
    userfriendly_message: str = Field(
        description="A user-friendly message to the user explaining the gallery parameters you chose.",
    )


# Define the agent
# Note: We define the agent *before* decorating the tool function
agent = Agent(
    "google-gla:gemini-2.0-flash",  # Using flash for speed/cost, consider 'gemini-1.5-pro'
    output_type=SuggestedBijukaruUrlParams,
    system_prompt=(
        "Extract the gallery parameters from the user's request "
        "and structure them according to the BijukaruUrlParams model. "
        "Infer the 'media_source' based on the context if not explicitly stated. "
        "If the user asks for ukiyo-e artists, you should infer the category id as 'artist:artist-name-slug' and the media_source as 'ukiyo-e'. "
        "Default 'media_source' to 'wikiart' if ambiguous. "
        "Identify specific image IDs, categories (like artists, styles, years, subreddits), "
        "slideshow interval, and other boolean flags or numeric settings mentioned. "
        "If you are unsure about a category, cannot find a specific ID, or if the user asks for suggestions, "
        "use the `perform_research` tool to get category suggestions based on the query. "
        "Once the tool provides suggestions, use the most relevant one to populate the parameters. "
        "You may also infer additional categories based on your own knowledge, returning the category ids in the correct format. You do not need to stick only to the examples in the case of wikiart, reddit or ukiyo-e media sources."
        "For example, if the user asks for 'katsushika hokusai', you should infer the category id as 'artist:katsushika-hokusai'."
        "If the user asks for a subreddit suggestion, you should infer the category id as 'subreddit:<subredditname>', for example 'subreddit:foxes'. The subreddit can be any subreddit, not just the ones in the examples. The subreddit should exist."
        "Make sure the category_id and image_id are in the correct format for the media source. "
        "For example:"
        "\n- WikiArt artists: 'artist:artist-name-slug'"
        "\n- WikiArt styles: 'style:style-name-slug'"
        "\n- Reddit: 'subreddit-name' (without 'r/')"
        "\n- Ukiyo-e artists: 'artist:artist-name-slug'"
        "Make sure you return the correct values for the category_id and image_id. If an image_id is specified, you must also return a category_id and media_source. Check that the image_id exists with the relevant search tool."
        "If you are unsure about the artist, use the `_search_wikiart_for_artists` tool to check whether the artist exists on WikiArt. If the artist is not found, don't return any categories."
        "If the user asks for a specific artist, try to point directly to 'artist:artist-name-slug' category instead of using the search_wikiart tool. If you cannot find the artist, use the `_search_wikiart_for_artists` tool to check whether the artist exists on WikiArt. If the artist is not found, don't return any categories."
        "Explain your reasoning for the category and image_id you chose."
        "Make sure the userfriendly_message is a user-friendly message to the user explaining the gallery parameters you chose, particularly the choice of category_id and image_id."
        f"These are some of the categories for the media sources: {get_all_categories()}"
    ),
    instrument=True,  # Optional: Enable instrumentation for logging/debugging
)


# Register perform_research as a tool using the decorator
@agent.tool_plain
async def perform_research_tool(query: str) -> Optional[LLMResearchResult]:
    """
    Use your own knowledge to find relevant categories for the query.

    Args:
        query: The user's research query, e.g., "Show me Australian artists"

    Returns:
        ResearchResult with research result, or None if an error occurs
    """
    print(f"--- Tool: Running research for query: {query} ---")
    result = await perform_research(query)
    print(f"--- Tool: Research result: {result} ---")
    return result


@agent.tool_plain
async def search_astronomy_images(query: str) -> Optional[SuggestedBijukaruUrlParams]:
    """
    If the user asks for astronomy images with specific search criteria, use this tool to search for relevant images.

    Args:
        query: A query to search for astronomy images, e.g. "galaxies" or "nebulae" or "star clusters"

    Returns:
        A SuggestedBijukaruUrlParams instance containing the search results, or None if an error occurs
    """
    return SuggestedBijukaruUrlParams(
        media_source="apod",
        category=f"search:{query}",
        image_id=None,
        interval=None,
        paused=None,
        hd=None,
        prefetch=None,
        fullscreen=None,
        showDescription=None,
        llm_thinking=f"Searching for astronomy images with the query: {query}",
        userfriendly_message=f"Showing results for '{query}' in Astronomy Picture of the Day",
    )


@agent.tool_plain
async def search_wikiart(query: str) -> Optional[SuggestedBijukaruUrlParams]:
    """
    Search for artworks on WikiArt using a specific query.

    Args:
        query: The query to search for. This should be a specific artist name, style, or a couple of words that describe the artwork. The query should be concise and to the point. Instead of "paintings of London", use "london" as the query.
               If the user asks for a specific artist, try to point directly to 'artist:artist-name-slug' category instead of using the search_wikiart tool. If you cannot find the artist, use the `_search_wikiart_for_artists` tool to check whether the artist exists on WikiArt. If the artist is not found, don't return any categories.
               If you want to search for multiple artists, separate the artist names with | in the query.

    Returns:
        A SuggestedBijukaruUrlParams instance containing the search results, or None if an error occurs
    """
    return SuggestedBijukaruUrlParams(
        media_source="wikiart",
        category=f"search:{query}",
        image_id=None,
        interval=None,
        paused=None,
        hd=None,
        prefetch=None,
        fullscreen=None,
        showDescription=None,
        llm_thinking=f"Searching for artworks on WikiArt with the query: {query}",
        userfriendly_message=f"Showing results for '{query}' on WikiArt",
    )


@agent.tool_plain
async def _search_wikiart_for_artists(artists: list[str]) -> list[WikiArtCategory]:
    """
    Check whether the artists exist on WikiArt. If so, return the relevant categories. If not, return an empty list.
    """
    return search_wikiart_for_artists(artists)


async def get_structured_params(query: str) -> Optional[SuggestedBijukaruUrlParams]:
    """
    Uses pydantic-ai Agent with Gemini to parse a query into BijukaruUrlParams.
    The agent can use the 'perform_research_tool' if needed.

    Args:
        query: The natural language query describing the desired gallery parameters.

    Returns:
        A BijukaruUrlParams instance populated from the query, or None if an error occurs.
    """
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        print("Error: GEMINI_API_KEY environment variable not set.")
        print(
            "Please get an API key from https://aistudio.google.com/apikey and set the variable."
        )
        return None

    print(f"Query: {query}")

    try:
        # Use agent.run() for async execution
        # The agent will automatically use the 'perform_research_tool' if its logic determines it's necessary based on the prompt.
        result = await agent.run(query)
        print("--- Agent Result ---")
        if result.output:
            print("Structured Output:")
            print(result.output.model_dump_json(indent=2))
            print("\nUsage:")
            print(result.usage())
            return result.output
        else:
            print("Agent did not produce valid structured output.")
            print("Messages:", result.all_messages())
            return None
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        import traceback

        traceback.print_exc()
        return None


async def perform_research(query: str) -> Optional[LLMResearchResult]:
    """
    Uses LLM knowledge to perform open-ended research on queries that don't directly match existing categories.

    Args:
        query: The user's research query, e.g., "Show me Australian artists"

    Returns:
        ResearchResult with research result, or None if an error occurs
    """
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        print("Error: GEMINI_API_KEY environment variable not set.")
        print(
            "Please get an API key from https://aistudio.google.com/apikey and set the variable."
        )
        return None

    # Using google-gla provider with Gemini model
    model_name = "google-gla:gemini-2.0-flash"

    # Define the agent
    agent = Agent(
        model_name,
        output_type=LLMResearchResult,
        system_prompt=(
            "You are a research assistant specializing in art, photography, and other visual media. "
            "Your task is to analyze the user's query and provide a concise research result. "
            "\n\n"
            "For example:"
            "\n- If they ask for 'Australian artists', provide a concise list of Australian artists "
            "\n- If they ask for a specific photography style or requests that don't fit into the other categories, provide a concise list of subreddits "
            "that might contain that style"
            "\n- If they ask about Japanese woodblock print artists, provide a concise list of Ukiyo-e artists "
            "\n\n"
            "Focus on providing accurate research."
        ),
        instrument=True,  # Enable instrumentation for logging
    )

    print(f"--- Running Research Agent ({model_name}) ---")
    print(f"Query: {query}")

    try:
        # Use agent.run() for async execution
        result = await agent.run(query)
        print("--- Research Agent Result ---")
        if result.output:
            print("Structured Output:")
            print(result.output.model_dump_json(indent=2))
            print("\nUsage:")
            print(result.usage())
            return result.output
        else:
            print("Agent did not produce valid research output.")
            print("Messages:", result.all_messages())
            return None
    except Exception as e:
        print(f"An unexpected error occurred during research: {e}")
        return None


# --- Multi-Agent Architecture --- #

# Agent 1: Story Curator
story_curator_agent = Agent(
    "google-gla:gemini-2.0-flash",
    output_type=NarrativePlan,
    system_prompt=(
        "You are an expert art historian and storyteller. Your task is to create a narrative plan based on the user's query (e.g., 'Van Gogh's life in 3 paintings'). "
        "Focus on selecting *which* artworks (by title and artist) best tell the requested story and explain *why* in the `narrative_description` for each item. "
        "Output a `NarrativePlan` containing a list of these conceptual `NarrativeItem`s. "
        "Specify the number of items requested by the user. If no number is specified, aim for 5-7 items. "
        "Do NOT worry about finding exact image URLs or links; that is the Researcher agent's job. Focus solely on the narrative coherence and artwork selection. "
        "Provide a `suggested_category_name` for the feed and explain your reasoning in `curator_llm_thinking`. Write a `curator_userfriendly_message` to introduce the story to the user."
        "You can use the `perform_research_for_curator` tool ONLY if you lack essential background knowledge about the topic to even start planning."
    ),
    instrument=True,
)


@story_curator_agent.tool_plain
async def perform_research_for_curator(query: str) -> Optional[LLMResearchResult]:
    """Use this tool ONLY for essential background research if you cannot understand the topic of the user's query well enough to select artworks. E.g., research an obscure art movement mentioned.
    Args:
        query: The specific background information needed.
    Returns:
        Research result or None.
    """
    print(f"--- Story Curator Tool: Running research for query: {query} ---")
    # Call the original perform_research function
    result = await perform_research(query)
    print(f"--- Story Curator Tool: Research result: {result} ---")
    return result


# Agent 2: Detail Researcher
detail_researcher_agent = Agent(
    "google-gla:gemini-2.0-flash",
    output_type=FeedItem,
    system_prompt="""You are a meticulous research assistant specializing in finding visual media details.
Your input is a JSON object describing a specific artwork (`ResearchRequest` with title and optional artist) and potentially some narrative context.
Your task is to find the most accurate `FeedItem` details for this single artwork.
Prioritize finding a valid source `link` (e.g., WikiArt artwork page, Reddit post, APOD page) and, if possible, a direct `image_url`.

**Tool Selection Strategy:**
1. **Determine Source:** Based on the title, artist, and narrative context, infer the most likely source (WikiArt, Ukiyo-e, Reddit, APOD).
2. **Use Specific Tool:** Call the *single most appropriate* tool for that source:
   - For general art/artists -> `get_wikiart_feed_for_researcher(category='search:<title> <artist>')`
   - For Japanese woodblock prints -> `get_ukiyo_e_feed_for_researcher(category='artist:<artist-slug>')` (if artist known) or try a relevant source category if mentioned.
   - For Reddit content -> `get_reddit_feed_for_researcher(subreddit=<subreddit_name>)` (You might need to infer the subreddit from the context).
   - For astronomy images -> `search_apod_for_researcher(query=<relevant keywords>)`
3. **Process Results:** From the results returned by the tool, select the BEST `FeedItem` match for the requested title/artist.
4. **Fallback:** If the first attempt yields no good match, you MAY try *one* alternative search (e.g., a broader query with the same tool, or `get_wikiart_feed_for_researcher` as a general fallback).
5. **Failure:** If you cannot find a reasonably certain match after 1-2 attempts, return a FeedItem with the original title/artist but null/empty link and image_url.

Do NOT invent details. Provide the found details in the `FeedItem` output format.
""",
    instrument=True,
)


@detail_researcher_agent.tool_plain
async def get_wikiart_feed_for_researcher(category: str) -> Optional[Feed]:
    """Fetches artwork data from WikiArt using a *specific category ID*.
    Use this with a SEARCH query (e.g., category='search:Monet Water Lilies') to find details for a specific artwork.
    You can also use 'artist:<slug>' if you need to browse an artist's works or simply search for the painting by name without the artist.
    Args:
        category: WikiArt category ID (e.g., 'search:query', 'artist:slug').
    Returns:
        Feed object with results, or None.
    """
    print(
        f"--- Detail Researcher Tool: Running get_wikiart_feed for category: {category} ---"
    )
    try:
        loop = asyncio.get_running_loop()
        # Call the original get_wikiart_feed function
        feed = await loop.run_in_executor(None, get_wikiart_feed, category)
        if feed and feed.items:
            print(
                f"--- Detail Researcher Tool: Found {len(feed.items)} items for {category} ---"
            )
            # Limit items
            max_items = 300
            if len(feed.items) > max_items:
                print(
                    f"--- Detail Researcher Tool: Truncating feed items to {max_items} ---"
                )
                feed.items = feed.items[:max_items]
            return feed
        else:
            print(f"--- Detail Researcher Tool: No items found for {category} ---")
            return None
    except Exception as e:
        print(
            f"--- Detail Researcher Tool: Error in get_wikiart_feed for {category}: {e} ---"
        )
        return None


@detail_researcher_agent.tool_plain
async def search_apod_for_researcher(query: str) -> Optional[Feed]:
    """Searches Astronomy Picture of the Day (APOD) for a specific query.
    Use this to find details for astronomy-related images.
    Args:
        query: The search term (e.g., 'nebula', 'galaxy', 'Crab Nebula').
    Returns:
        Feed object with results, or None.
    """
    print(f"--- Detail Researcher Tool: Running search_apod for query: {query} ---")
    try:
        # search_apod is already async
        feed = await search_apod(query)
        if feed and feed.items:
            print(
                f"--- Detail Researcher Tool: Found {len(feed.items)} items for APOD query '{query}' ---"
            )
            # Limit results
            max_items = 300
            if len(feed.items) > max_items:
                print(
                    f"--- Detail Researcher Tool: Truncating APOD items to {max_items} ---"
                )
                feed.items = feed.items[:max_items]
            return feed
        else:
            print(
                f"--- Detail Researcher Tool: No items found for APOD query '{query}' ---"
            )
            return None
    except Exception as e:
        print(
            f"--- Detail Researcher Tool: Error in search_apod for '{query}': {e} ---"
        )
        return None


@detail_researcher_agent.tool_plain
async def get_ukiyo_e_feed_for_researcher(category: str) -> Optional[Feed]:
    """Fetches artwork data from ukiyo-e.org for a specific category or artist.
    Use this to find details for Japanese woodblock prints.
    Args:
        category: The source category (e.g., 'mfa', 'pulverer') or artist slug ('artist:katsushika-hokusai').
    Returns:
        Feed object with results, or None.
    """
    print(
        f"--- Detail Researcher Tool: Running get_ukiyo_e_feed for category: {category} ---"
    )
    try:
        # get_ukiyo_e_feed is synchronous
        loop = asyncio.get_running_loop()
        feed = await loop.run_in_executor(None, get_ukiyo_e_feed, category)
        if feed and feed.items:
            print(
                f"--- Detail Researcher Tool: Found {len(feed.items)} items for Ukiyo-e category '{category}' ---"
            )
            # Limit results
            max_items = 300
            if len(feed.items) > max_items:
                print(
                    f"--- Detail Researcher Tool: Truncating Ukiyo-e items to {max_items} ---"
                )
                feed.items = feed.items[:max_items]
            return feed
        else:
            print(
                f"--- Detail Researcher Tool: No items found for Ukiyo-e category '{category}' ---"
            )
            return None
    except Exception as e:
        print(
            f"--- Detail Researcher Tool: Error in get_ukiyo_e_feed for '{category}': {e} ---"
        )
        return None


@detail_researcher_agent.tool_plain
async def get_reddit_feed_for_researcher(subreddit: str) -> Optional[Feed]:
    """Fetches top image posts from a specific subreddit.
    Use this to find details for images likely sourced from Reddit.
    Args:
        subreddit: The name of the subreddit (without 'r/').
    Returns:
        Feed object with results, or None.
    """
    print(
        f"--- Detail Researcher Tool: Running get_reddit_feed for subreddit: {subreddit} ---"
    )
    try:
        # get_reddit_feed is synchronous
        loop = asyncio.get_running_loop()
        feed = await loop.run_in_executor(None, get_reddit_feed, subreddit)
        if feed and feed.items:
            print(
                f"--- Detail Researcher Tool: Found {len(feed.items)} items for subreddit '{subreddit}' ---"
            )
            # Limit results
            max_items = 300
            if len(feed.items) > max_items:
                print(
                    f"--- Detail Researcher Tool: Truncating Reddit items to {max_items} ---"
                )
                feed.items = feed.items[:max_items]
            return feed
        else:
            print(
                f"--- Detail Researcher Tool: No items found for subreddit '{subreddit}' ---"
            )
            return None
    except Exception as e:
        print(
            f"--- Detail Researcher Tool: Error in get_reddit_feed for '{subreddit}': {e} ---"
        )
        return None


# --- Orchestrating Function (Manager Logic) --- #


async def generate_curated_feed_multi_agent(query: str) -> Optional[CuratedFeed]:
    """Orchestrates the Curator and Researcher agents to generate a curated feed."""
    print(f"--- Manager: Starting multi-agent process for query: {query} ---")

    # 1. Call Story Curator
    print("--- Manager: Calling Story Curator Agent ---")
    narrative_plan_result = await story_curator_agent.run(query)
    if not narrative_plan_result or not narrative_plan_result.output:
        print("--- Manager: Story Curator failed to produce a narrative plan. ---")
        return None

    narrative_plan: NarrativePlan = narrative_plan_result.output
    print(
        f"--- Manager: Story Curator returned plan for '{narrative_plan.suggested_category_name}' with {len(narrative_plan.items)} items. ---"
    )

    # 2. Call Detail Researcher for each item
    final_feed_items: list[FeedItem] = []
    for i, item_to_research in enumerate(narrative_plan.items):
        print(
            f"--- Manager: Calling Detail Researcher Agent for item {i+1}/{len(narrative_plan.items)}: '{item_to_research.title}' ---"
        )
        research_request = ResearchRequest(
            title=item_to_research.title, artist=item_to_research.artist
        )
        research_input = (
            research_request.model_dump_json()
        )  # Pass request as JSON string

        # Add narrative context to researcher input? Might help disambiguate. Let's try adding it to the prompt implicitly via input string.
        research_input_prompt = f"Find details for this artwork based on the request: {research_input}. Narrative context: {item_to_research.narrative_description}"

        detailed_item_result = await detail_researcher_agent.run(research_input_prompt)

        if detailed_item_result and detailed_item_result.output:
            found_item: FeedItem = detailed_item_result.output
            # Combine researcher data with curator's narrative description
            found_item.description = item_to_research.narrative_description
            # Ensure artist name is consistent if researcher found it
            if not found_item.artist_name and item_to_research.artist:
                found_item.artist_name = item_to_research.artist
            final_feed_items.append(found_item)
            print(
                f"--- Manager: Detail Researcher found details for item {i+1}. Link: {found_item.link} ---"
            )
        else:
            print(
                f"--- Manager: Detail Researcher failed for item {i+1}. Adding placeholder. ---"
            )
            # Add a placeholder item if researcher fails
            placeholder_item = FeedItem(
                id=f"placeholder-{i+1}-{item_to_research.title.replace(' ', '-')[:20]}",
                title=f"{item_to_research.title} (Details not found)",
                artist_name=item_to_research.artist,
                description=item_to_research.narrative_description,
                image_url="",
                link="",
            )
            final_feed_items.append(placeholder_item)

    # 3. Assemble Final Feed
    print("--- Manager: Assembling final CuratedFeed ---")
    final_feed = CuratedFeed(
        items=final_feed_items,
        category=Category(
            id=f"narrative:{narrative_plan.suggested_category_name.lower().replace(' ', '-')[:30]}",
            name=narrative_plan.suggested_category_name,
        ),
        llm_thinking=narrative_plan.curator_llm_thinking,  # Use curator's thinking
        userfriendly_message=narrative_plan.curator_userfriendly_message,  # Use curator's message
    )

    print("--- Manager: Multi-agent process complete. ---")
    return final_feed


# --- End Multi-Agent Architecture --- #

# --- Main execution block --- #
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description=(
            "Extract structured gallery parameters or generate a curated feed "
            "from a natural language query."
        )
    )
    parser.add_argument("query", type=str, help="The natural language query.")
    parser.add_argument(
        "--mode",
        type=str,
        choices=["params", "curate"],
        default="params",
        help="'params' to get BijukaruUrlParams, 'curate' to get a CuratedFeed.",
    )
    args = parser.parse_args()

    if args.mode == "params":
        print("--- Running in Parameter Extraction Mode ---")
        structured_output: Optional[SuggestedBijukaruUrlParams] = asyncio.run(
            get_structured_params(args.query)
        )
        if structured_output:
            print(f"Generated URL: {structured_output.url}")
        else:
            print("\nFailed to get structured parameters.")

    elif args.mode == "curate":
        print("--- Running in Feed Curation Mode (Multi-Agent) ---")
        curated_feed_output: Optional[CuratedFeed] = asyncio.run(
            generate_curated_feed_multi_agent(args.query)
        )
        if curated_feed_output:
            print(
                f"\nGenerated Curated Feed for Category: {curated_feed_output.category.name}"
            )
            print(f"Number of items: {len(curated_feed_output.items)}")
            print(curated_feed_output.model_dump_json(indent=2))
        else:
            print("\nFailed to generate curated feed.")
